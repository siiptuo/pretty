#!/bin/bash

# pretty - prettify many formats with single command
#
# Written in 2017 by Tuomas Siipola
#
# To the extent possible under law, the author(s) have dedicated all
# copyright and related and neighboring rights to this software to the
# public domain worldwide. This software is distributed without any
# warranty.  You should have received a copy of the CC0 Public Domain
#
# Dedication along with this software. If not, see
# <http://creativecommons.org/publicdomain/zero/1.0/>. 

function usage {
    echo 'Usage: pretty [-i | -o OUTPUT] INPUT'
    exit 1
}

inplace=false
output=

while getopts ':hio:' opt; do
    case $opt in
        h) usage;;
        i) inplace=true;;
        o) output="$OPTARG";;
        ?) echo "Invalid option: -$OPTARG"; usage;;
    esac
done

shift $((OPTIND - 1))
input=$1

if [ -n "$output" ] && [ "$inplace" = true ]; then
    echo "Choose either -i or -o"
    usage
fi

if [ -z "$input" ]; then
    echo "No input given"
    usage
fi

extension=${input##*.}

cmd=
cmd_stdout=

case "${extension,,}" in
    "json")
        if [ -x "$(command -v jq)" ]; then
            cmd="jq --indent 4 ."
            cmd_stdout="jq --indent 4 --monochrome-output ."
        elif [ -x "$(command -v python)" ]; then
            cmd="python -m json.tool"
            cmd_stdout=$cmd
        elif [ -x "$(command -v json-glib-format)" ]; then
            cmd="json-glib-format --indent-spaces 4 --prettify"
            cmd_stdout=$cmd
        elif [ -x "$(command -v json_xs)" ]; then
            cmd="json_xs <"
            cmd_stdout=$cmd
        # TODO: json_reformat from yajl
        # TODO: aeson-pretty
        # TODO: jshon
        else
            echo "No JSON formatter found"
            exit 1
        fi
        ;;
    "js")
        if [ -x "$(command -v uglifyjs)" ]; then
            cmd="uglifyjs --beautify --"
            cmd_stdout=$cmd
        elif [ -x "$(command -v js-beautify)" ]; then
            cmd="js-beautify"
            cmd_stdout=$cmd
        else
            echo "No JavaScript formatter found"
            exit 1
        fi
        ;;
    "css")
        if [ -x "$(command -v cleancss)" ]; then
            cmd="cleancss --format beautify"
            cmd_stdout=$cmd
        elif [ -x "$(command -v beautify-css)" ]; then
            cmd="beautify-css <"
            cmd_stdout=$cmd
        elif [ -x "$(command -v cssparse)" ]; then
            cmd="cssparse"
            cmd_stdout=$cmd
        else
            echo "No CSS formatter found"
            exit 1
        fi
        ;;
    "xml")
        if [ -x "$(command -v xmllint)" ]; then
            cmd="xmllint --format"
            cmd_stdout=$cmd
        elif [ -x "$(command -v xml_pp)" ]; then
            cmd="xml_pp"
            cmd_stdout=$cmd
            # TODO: support -i for in place edit
        elif [ -x "$(command -v xml)" ]; then
            cmd="xml format"
            cmd_stdout=$cmd
        elif [ -x "$(command -v tidy)" ]; then
            cmd="tidy --quiet yes --input-xml yes --output-xml yes --indent yes --indent-attributes yes --vertical-space yes"
            cmd_stdout=$cmd
            # TODO: support --output-file and --write-back
        else
            echo "No XML formatter found"
            exit 1
        fi
        ;;
    "html" | "htm")
        if [ -x "$(command -v tidy)" ]; then
            cmd="tidy --quiet yes --indent yes"
            cmd_stdout=$cmd
            # TODO: support --output-file and --write-back
        elif [ -x "$(command -v xml)" ]; then
            cmd="xml format --html"
            cmd_stdout=$cmd
        else
            echo "No HTML formatter found"
            exit 1
        fi
        ;;
    "sql")
        if [ -x "$(command -v sqlformat)" ]; then
            cmd="sqlformat --keywords upper --identifiers lower --reindent"
            cmd_stdout=$cmd
        else
            echo "No HTML formatter found"
            exit 1
        fi
        ;;
    *)
        echo "Unknown format with file extension: $extension"
        exit 1
        ;;
esac

if [ -n "$output" ]; then
    eval "$cmd" "$input" > "$output"
elif [ "$inplace" = true ]; then
    tmp="$(mktemp)"
    eval "$cmd" "$input" > "$tmp"
    mv "$tmp" "$input"
else
    eval "$cmd_stdout" "$input"
fi
